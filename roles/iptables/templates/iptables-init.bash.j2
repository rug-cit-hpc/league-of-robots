#!/bin/bash

#
# Script to configure an iptables based firewall using a template from an Ansible playbook role "iptables".
# DO NOT EDIT this file manually; edit the the template instead and redeploy using Ansible!
#
# This file must be located in /etc/sysconfig/iptables-init.bash 
#
# Common port reference:
#   22: SSH
#   25: SMTP
#   80: HTTP
#   123: NTP
#   443: HTTPS

#
# Bash sanity.
#
set -u

#
# Hosts and interfaces.
#
TARGET_SERVER='{{ ansible_hostname }}'
declare -a INTERNAL_INTERFACES=(
{% for internal_interface in internal_interfaces %}
	'{{ internal_interface }}'
{% endfor %}
)
declare -a EXTERNAL_INTERFACES=(
{% for external_interface in external_interfaces %}
	'{{ external_interface }}'
{% endfor %}
)

#
# Network addresses and ranges.
#
LOOPBACK='127.0.0.0/8'

declare -a ALLOW_ICMP_INBOUND=(
{% for ip in iptables_allow_icmp_inbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare -a ALLOW_SSH_INBOUND=(
{% for ip in iptables_allow_ssh_inbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare -a ALLOW_SSH_OUTBOUND=(
{% for ip in iptables_allow_ssh_outbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare -a ALLOW_EBI_MYSQL_OUTBOUND=(
{% for ip in iptables_allow_ebi_mysql_outbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare -a ALLOW_FTP_OUTBOUND=(
{% for ip in iptables_allow_ftp_outbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare -a ALLOW_ASPERA_OUTBOUND=(
{% for ip in iptables_allow_aspera_outbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare -a ALLOW_GLOBUS_OUTBOUND=(
{% for ip in iptables_allow_globus_outbound %}
	'{{ ip_addresses[ip].addr }}'	# {{ ip_addresses[ip].desc }}
{% endfor %}
)
declare GLOBUS_ORG_NET='{{ ip_addresses.globus_org_net.addr }}'	# {{ ip_addresses.globus_org_net.desc }}
declare GOOGLE_STUN='{{ ip_addresses.google_stun.addr }}'		# {{ ip_addresses.google_stun.desc }}

#
##
### Main.
##
#

#
# Get (short) name of the server where this script is executed.
#  * Ignore the domain.
#  * Remove any -mgmt suffixes
#
SERVER_NAME="$(hostname -s)"
SERVER_NAME="$(echo ${SERVER_NAME} | sed 's/-mgmt//')"

#
# Check if we have a config valid for this server.
#
if [[ "${SERVER_NAME}" == "${TARGET_SERVER}" ]]; then
	echo "INFO: Hostname check passed. Will configure iptables firewall..."
else
	echo "ERROR: This config file is for \"${TARGET_SERVER}\", but this is \"${SERVER_NAME}\"."
	echo 'FATAL: Cannot configure firewall on this server.'
	exit 1
fi

#
##
### Kernel tweaks.
##
#

#
# Disable redirects and forwarding, which are only required on routers.
#
echo '0' > /proc/sys/net/ipv4/conf/all/forwarding
echo '0' > /proc/sys/net/ipv6/conf/all/forwarding
echo '0' > /proc/sys/net/ipv4/conf/all/accept_redirects
echo '0' > /proc/sys/net/ipv6/conf/all/accept_redirects

#
# Prevent SYNC-floods.
#
echo '1' > /proc/sys/net/ipv4/tcp_syncookies # confusing name, but applies to IP version 6 as well.

#
# Limit response to ICMP packets.
#
echo '1' > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
echo '1' > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

#
# Disable logging of spoofed packets, source routed packets, 
# and redirect packets to prevent flooding the logs.
#
echo '0' > /proc/sys/net/ipv4/conf/all/log_martians

#
# Disable source routed packets, which should only be required for debugging network issues.
#
echo '0' > /proc/sys/net/ipv4/conf/all/accept_source_route
echo '0' > /proc/sys/net/ipv6/conf/all/accept_source_route

#
# Enable IP spoofing protection.
#
echo '1' > /proc/sys/net/ipv4/conf/all/rp_filter

#
##
### IPv6: disable all and log.
##
#

#
# Flush and delete existing rules.
#
ip6tables -F
ip6tables -X

#
# Set the default policies to drop everything.
#
ip6tables -P INPUT DROP
ip6tables -P OUTPUT DROP
ip6tables -P FORWARD DROP

#
# We must accept IPv6 traffic on the loopback interface to prevent tests from failing
# during installation of verious software packages with network functionality.
#
ip6tables -A INPUT  -i lo -j ACCEPT
ip6tables -A OUTPUT -o lo -j ACCEPT

#
##
### IPv4.
##
#

#
# Initialize and flush everything to start with a clean slate.
#
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
iptables -t security -F
iptables -t security -X
iptables -Z

#
# Create custom chain for LOGDROP.
#
iptables -N LOGDROP
iptables -A LOGDROP -m limit --limit 15/minute -j LOG --log-level 7 --log-prefix 'Dropped by iptables firewall: '
iptables -A LOGDROP -j DROP

#
# Config default policies to drop.
#
# Log EVERYTHING (ONLY for Debugging).
# iptables -A INPUT -j LOG
{% if iptables_log_dropped_packets %}
iptables -P INPUT   LOGDROP
{% else %}
iptables -P INPUT   DROP
{% endif %}
iptables -P OUTPUT  DROP
iptables -P FORWARD DROP

#
# Refuse loopback packets incoming from external interface.
#
for EXT_INTERFACE in "${EXTERNAL_INTERFACES[@]:-}"; do
	[[ -z "${EXT_INTERFACE}" ]] && continue
	iptables -A INPUT -i "${EXT_INTERFACE}" -d "${LOOPBACK}" -j DROP
done

#
# Allow loopback.
#
iptables -A INPUT  -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

#
# Allow anything over internal interfaces.
#
for INT_INTERFACE in "${INTERNAL_INTERFACES[@]:-}"; do
	[[ -z "${INT_INTERFACE}" ]] && continue
	iptables -A INPUT  -i "${INT_INTERFACE}" -j ACCEPT
	iptables -A OUTPUT -o "${INT_INTERFACE}" -j ACCEPT
done

#
# Filter traffic over external interfaces.
#
for EXT_INTERFACE in "${EXTERNAL_INTERFACES[@]:-}"; do
	[[ -z "${EXT_INTERFACE}" ]] && continue
	#
	# Allow all outbound ICMP.
	# Allow limited inbound ICMP:
	#    Type 0    Echo Reply   (a.k.a. pong) must be RELATED.
	#    Type 8    Echo Request (a.k.a. ping)
	#    Type 3    Destination Unreachable:
	#              Unable to deliver the datagram to the specified network, host, protocal, or port.
	#              Also sent if the datagram needs to be fragmented and the the Don't Fragment flag is on.
	#              Required for Path-MTU Discovery and to prevent a PMTU "black hole".
	#    Type 11   Time Exceeded:
	#              The Time To Live (TTL) for the datagram has been exceeded.
	#              Required for traceroute.
	#
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p icmp -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p icmp -m state --state ESTABLISHED,RELATED     -j ACCEPT
	for IP_ADDRESS in ${ALLOW_ICMP_INBOUND[@]}; do
		iptables -A INPUT  -i ${EXT_INTERFACE} -p icmp --icmp-type 3  -s ${IP_ADDRESS} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
		iptables -A INPUT  -i ${EXT_INTERFACE} -p icmp --icmp-type 8  -s ${IP_ADDRESS} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
		iptables -A INPUT  -i ${EXT_INTERFACE} -p icmp --icmp-type 11 -s ${IP_ADDRESS} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	done
	#
	# Allow outbound NTP.
	#
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p udp --dport 123 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p udp --sport 123 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound SMTP.
	#
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp -m multiport --dport 25,587 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp -m multiport --sport 25,587 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound DNS.
	#
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p udp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p udp --sport 53 -m state --state ESTABLISHED     -j ACCEPT
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp --sport 53 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound HTTP.
	#
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp --sport 80 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound HTTPS.
	#
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp --sport 443 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow SSH inbound and outbound.
	#
	for IP_ADDRESS in ${ALLOW_SSH_INBOUND[@]}; do
		iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp -s ${IP_ADDRESS} --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	for IP_ADDRESS in ${ALLOW_SSH_OUTBOUND[@]}; do
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp -d ${IP_ADDRESS} --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables   -A OUTPUT -o ${EXT_INTERFACE} -p tcp                    --sport 22 -m state --state ESTABLISHED     -j ACCEPT
	iptables   -A INPUT  -i ${EXT_INTERFACE} -p tcp                    --sport 22 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow MySQL outbound.
	#
	# Required a.o. for conncections to the public Ensembl databases via the Ensembl Perl API
	#
	for IP_ADDRESS in ${ALLOW_EBI_MYSQL_OUTBOUND[@]}; do
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp -d ${IP_ADDRESS} -m multiport --dports 3306,5306,5316 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp                      -m multiport --sports 3306,5306,5316 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow FTP outbound.
	#
	# We need a default and an additional connection tracking kernel module 
	# in order to track FTP connections and know what is a RELATED connection.
	# The extra module must be added to /etc/sysconfig/iptables-config
	#    IPTABLES_MODULES="nf_conntrack_ftp"
	#
	/sbin/modprobe nf_conntrack     # Default module: should already be present, just checking here.
	/sbin/modprobe nf_conntrack_ftp # Extra module: should be added to /etc/sysconfig/iptables-config, just checking here.
	#
	# Firstly, allow FTP control initiated by the client.
	#
	for IP_ADDRESS in ${ALLOW_FTP_OUTBOUND[@]}; do
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp -d ${IP_ADDRESS} --dport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables   -A INPUT  -i ${EXT_INTERFACE} -p tcp                    --sport 21 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Secondly, allow FTP data connections.
	#  * For Active Mode FTP the client must accept RELATED connections from the server on port 20 
	#    to the client on a port number negotiated in the FTP control connection.
	#  * For Passive Mode FTP the client starts a RELATED connection from a random own high port number 
	#    to the server's fixed high port number negotiated in the FTP control connection.
	#  * For both Active and Passive Mode FTP, the nf_conntrack_ftp kernel module is required at the FTP client 
	#    to pick up the negotiated port number from the FTP control packet payloads.
	#
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp --sport 20                  -m state --state ESTABLISHED,RELATED -j ACCEPT # Active Mode
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp --dport 20                  -m state --state ESTABLISHED         -j ACCEPT # Active Mode
	iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED,RELATED -j ACCEPT # Passive Mode
	iptables -A INPUT  -i ${EXT_INTERFACE} -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED         -j ACCEPT # Passive Mode
	#
	# Allow Aspera outbound.
	#
	# Aspera requires (most common configs):
	#  * SSH on either TCP port 22 or TCP 33001 for control and
	#  * Data stream on at least UDP port 33001.
	#    In case the server OS doesn't allow UDP port sharing a range of UDP ports is used
	#    where the number of ports determines the max number of concurrent connections/clients.
	#
	for IP_ADDRESS in ${ALLOW_ASPERA_OUTBOUND[@]}; do
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp -d ${IP_ADDRESS} -m multiport --dports 22,33001    -m state --state NEW,ESTABLISHED -j ACCEPT
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p udp -d ${IP_ADDRESS} -m multiport --dports 33001:33100 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables   -A INPUT  -i ${EXT_INTERFACE} -p tcp                    -m multiport --sports 22,33001    -m state --state ESTABLISHED     -j ACCEPT
	iptables   -A INPUT  -i ${EXT_INTERFACE} -p udp                    -m multiport --sports 33001:33100 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow Globus outbound.
	#
	# Globus requires (most common configs) for "broker" service:
	#  * TCP port  2223        outbound for control channel with the Globus Transfer service and for obtaining certificates during initial setup.
	#                          Normally this will be the *.globus.org subnet.
	#  * UDP port 19302        outbound for connecting to STUN server when setting up a session with another Globus Connect Personal endpoint.
	#                          Normally this will be the stun.l.google.com Google STUN server.
	# For each endpoint:
	#  * TCP ports 50000-51000 outbound for data channel for transfers with Globus Connect Server endpoints.
	#  * UDP ports 32768-65535 outbound for data channel for transfers with other Globus Connect Personal endpoints.
	#
	iptables   -A OUTPUT -o ${EXT_INTERFACE} -p tcp -d ${GLOBUS_ORG_NET}            --dport 2223  -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables   -A OUTPUT -o ${EXT_INTERFACE} -p udp -d ${GOOGLE_STUN}               --dport 19302 -m state --state NEW,ESTABLISHED -j ACCEPT
	for IP_ADDRESS in ${ALLOW_GLOBUS_OUTBOUND[@]}; do
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p tcp -d ${IP_ADDRESS} -m multiport --dports 50000:51000 -m state --state NEW,ESTABLISHED -j ACCEPT
		iptables -A OUTPUT -o ${EXT_INTERFACE} -p udp -d ${IP_ADDRESS} -m multiport --dports 32678:65535 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
done

#
# (Re)start fail2ban, so it will (re)create a custom f2b-SSH iptables chain.
#
#service fail2ban restart

#
# List the rules:
#
echo '#'
echo '##'
echo '### iptables --list -n ###'
echo '##'
echo '#'
iptables --list -n
echo '#'
echo '##'
echo '### ip6tables --list -n ###'
echo '##'
echo '#'
ip6tables --list -n

#
# Save config for next boot.
#
service iptables save
service ip6tables save
